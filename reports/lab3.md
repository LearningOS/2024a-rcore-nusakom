## 问答作业

### 1. **关于两个进程的执行顺序问题**

首先，我们来分析原问题：

- **进程 p1** 和 **进程 p2** 的 `stride` 分别是 255 和 250。
- 在第一个时间片执行后，**进程 p2** 执行了一个时间片（假设使用 8-bit 无符号整型储存 stride，最大值为 255），此时 `p2.stride` 变成了 `250 + 255 = 505`。
- 理论上，下一次应该轮到 `p1` 执行，因为它的 `stride`（255）比 `p2` 的 `stride`（505）小。

但是，实际情况是，**`p1` 不一定会立即执行**。这是因为在使用 8 位无符号整数时，如果 `p1.stride` 和 `p2.stride` 的值都非常大，可能会发生溢出。

例如，考虑如下情况：
- `p1.stride = 255`
- `p2.stride = 250`

在执行一个时间片后，`p2.stride` 会变为 `250 + 255 = 505`。由于 `stride` 是 8 位无符号整数，这个值会溢出，导致 `p2.stride` 变成 `505 - 256 = 249`。然后 `p1.stride` 仍然是 255，`p2.stride` 变成了 249，因此下一次应该是 **`p2` 执行**。

### 2. **为什么要求进程的优先级 >= 2**

为了防止上述溢出问题，要求进程优先级大于等于 2 是一种设计上的策略。这是因为如果所有进程的优先级（或 `stride`）至少为 2，那么我们可以避免溢出的影响。可以证明，**当所有进程的 `stride` >= 2 时，`stride` 的最大值与最小值之间的差距不会大于 `BigStride / 2`**。

这个结论的简单解释是：
- 假设 `BigStride` 是 255，并且所有进程的 `stride` 至少为 2。
- 如果 `stride` 的最小值为 2，而最大值为 255，那么两个进程的 `stride` 之间的差值最大也就是 `255 - 2 = 253`。
- 然而，如果 `stride` 的值始终大于等于 2，那么在算法运行时，相比最大值（如 255），最小值（如 2）的比例差异将会被限制在一个小的范围内，从而避免发生溢出。

### 3. **在考虑溢出的情况下，如何设计比较器**

现在，我们可以根据题目要求，为 `Stride` 设计一个合适的比较器。为了避免溢出带来的问题，我们可以使用一个特殊的比较器，在比较时处理溢出情况。我们需要确保，**比较时应该将溢出的 `stride` 正确地比较**，使得溢出的情况不会影响算法的执行。

以下是 `partial_cmp` 函数的实现：

```rust
use core::cmp::Ordering;

struct Stride(u64);

impl PartialOrd for Stride {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        // 计算实际的 stride 值，这里假设 stride 是8bit的无符号整数
        let self_normalized = self.0 % 256; // 8-bit范围内的值
        let other_normalized = other.0 % 256; // 8-bit范围内的值

        // 比较 normalized stride 值
        if self_normalized < other_normalized {
            Some(Ordering::Less)
        } else if self_normalized > other_normalized {
            Some(Ordering::Greater)
        } else {
            Some(Ordering::Equal)
        }
    }
}

impl PartialEq for Stride {
    fn eq(&self, other: &Self) -> bool {
        false // 题目假设 stride 不会相等
    }
}
```

### 4. **解释**

- **`self.0 % 256` 和 `other.0 % 256`**：这部分代码保证了对 `stride` 的正常化处理，将 `stride` 值限制在 8 位无符号整数的范围内（0-255），避免溢出的影响。
- 比较 `self_normalized` 和 `other_normalized`，而不是直接比较原始的 `stride` 值，这样可以确保即使发生溢出，比较器也能够正确地返回比较结果。

### 5. **总结**

在设计 `stride` 算法时，溢出问题是一个需要特别注意的地方。通过引入限制（如要求 `stride` 最小值为 2），可以有效避免溢出对调度策略的影响。此外，在比较 `stride` 值时，通过使用模 256 的操作，确保即使发生溢出，算法也能保持正确的行为。

## 总结

在这个编程作业中，成功实现了一个自定义的进程创建系统调用 sys_spawn 和带优先级的调度算法（Stride 调度）。sys_spawn 简化了进程创建的过程，避免了 fork 和 exec 的复杂性，而 Stride 调度算法则通过调整进程的 stride 和 pass 来实现基于优先级的公平调度。

## 荣誉准则

1.在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

    《你交流的对象说明》

2.此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

    《你参考的资料说明》

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。