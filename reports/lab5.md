### 问答作业

#### 1. 主线程退出时需要回收的资源

当主线程（0号线程）退出时，整个进程需要回收的资源包括：

1. **线程的 Task Control Blocks (TCBs)**：
   - 每个线程都有一个 TCB，它存储线程的状态、堆栈、寄存器上下文等信息。当线程退出时，需要回收这些结构体以释放内存。

2. **线程栈**：
   - 每个线程在创建时分配了自己的栈空间，主线程退出时需要回收所有线程的栈空间。

3. **锁和信号量**：
   - 如果线程在使用互斥锁或信号量等同步原语，这些资源需要被释放，以防止死锁或资源泄漏。

4. **动态分配的内存**：
   - 如果线程使用动态分配的内存（例如通过 `malloc` 或 `new`），这些内存也需要被释放。

5. **文件描述符和网络连接**：
   - 打开的文件、网络连接等也需要在进程退出时关闭，以释放资源。

#### 2. 其他线程的 TCB 可能的引用位置及是否需要回收

其他线程的 TCB 可能在以下位置被引用：

1. **调度器**：
   - 调度器可能保持对每个线程 TCB 的引用。此时，主线程退出时，应确保释放这些引用，防止内存泄漏。

2. **等待队列**：
   - 如果其他线程在等待某个资源（例如互斥锁），它们的 TCB 可能在等待队列中。这些 TCB 需要回收，因为主线程退出时不再需要调度这些线程。

3. **系统调用栈**：
   - 在系统调用的执行过程中，TCB 可能会被保存到内核栈中。当主线程退出时，应检查并释放这些 TCB。

4. **全局或共享数据结构**：
   - 在某些实现中，TCB 可能被存储在全局或共享数据结构中。主线程退出时，这些数据结构也需要处理以释放 TCB。

回收的原因是，主线程退出时，所有其他线程的 TCB 都不再有效，继续引用它们将导致未定义行为或内存泄漏。

---

### Mutex.unlock 实现的比较

#### Mutex1 和 Mutex2 的实现区别

1. **锁状态设置的顺序**：
   - **Mutex1**：在弹出等待队列中的线程之前，先将 `locked` 状态设置为 `false`。
   - **Mutex2**：只有在没有线程在等待时，才会将 `locked` 状态设置为 `false`，如果有线程在等待，则先弹出等待队列中的线程。

2. **条件判断的位置**：
   - **Mutex1** 在解锁时不考虑是否有线程在等待，始终将锁状态设置为 `false`。
   - **Mutex2** 则通过判断是否有等待的线程，决定是否设置锁状态。

#### 可能导致的问题

1. **Mutex1 的问题**：
   - 如果 `Mutex1` 在没有等待线程的情况下错误地将 `locked` 状态设置为 `false`，这会导致随后的锁定操作没有正确的状态检查，可能会造成竞争条件。
   - 另外，其他线程可能在此时错误地认为锁已经被释放，从而继续执行，这可能导致不安全的操作。

2. **Mutex2 的问题**：
   - 虽然 `Mutex2` 的设计较为保守，避免了在有等待线程时错误释放锁，但如果在高并发环境下，多个线程同时尝试解锁同一个互斥量，可能会导致一些线程饿死（即永远无法获取锁），因为它们会被无限期地挂起。

总体而言，Mutex1 更容易导致数据竞争和安全性问题，而 Mutex2 在某些情况下可能引入性能瓶颈，尤其在高并发情况下。确保在设计互斥锁时要充分考虑这些因素，以平衡安全性和性能。

## 实验报告

在本次实验中，我实现了死锁检测机制，并加入了 sys_enable_deadlock_detect 系统调用，用于启用或禁用死锁检测功能。死锁检测基于银行家算法，通过对资源的可用情况、分配情况以及每个线程的需求情况，判断系统是否处于死锁状态。

具体的实现步骤如下：

死锁检测算法：在启用死锁检测功能后，每次请求资源时会检查是否会导致死锁。如果死锁检测发现系统无法满足当前线程的资源需求且不会有线程完成并释放资源，则会拒绝该请求，返回错误码 -0xDEAD。

sys_enable_deadlock_detect 系统调用：用于开启或关闭死锁检测功能。调用此系统调用时，若参数为 1，则启用死锁检测，若为 0，则禁用。

资源管理：包括更新可用资源、分配资源矩阵和需求矩阵，确保死锁检测在每次资源分配前都能正确判断当前状态。

## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

   《你交流的对象说明》

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

   《你参考的资料说明》

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。